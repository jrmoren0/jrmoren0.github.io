<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Virtual Projector and Dual Hydra Editor</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<script src="https://unpkg.com/hydra-synth"></script>
<style>
  body { margin:0; overflow:hidden; background-color: #000; }
  
  /* --- UI Container Styling --- */
  #controlPanel {
    position: absolute;
    top: 8px;
    left: 8px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.9);
    color: white;
    font-family: Arial, sans-serif;
    border-radius: 5px;
    max-height: 90vh;
    overflow-y: auto;
    z-index: 20;
    width: 320px;
    user-select: none;
    transition: opacity 0.3s;
  }
  .slider-group { margin-bottom: 12px; padding-bottom: 5px; border-bottom: 1px dashed #333; }
  .slider-group:last-child { border-bottom: none; }
  .slider-group label { display: block; font-size: 13px; margin-bottom: 3px; }
  .slider-group input[type="range"] { width: 100%; }
  .slider-value { float: right; font-weight: bold; font-size: 13px; color: #00FFC6; }
  .button-group button {
    padding: 8px 10px;
    margin-right: 5px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    margin-top: 5px;
  }
  .button-group button.toggle-button { background: #dc3545; }
  .button-group button:hover { background: #0056b3; }
  .button-group button.toggle-button:hover { background: #c82333; }


  /* Code Editors */
  #hydraSetupCode, #hydraOutputCode {
    width: 100%;
    background: #222;
    color: #f8f8f2;
    font-family: monospace;
    font-size: 12px;
    border: 1px solid #444;
    padding: 5px;
    resize: vertical;
  }
  #hydraSetupCode { height: 70px; }
  #hydraOutputCode { height: 120px; }
  #runOutputCodeButton { background: #28a745; }
  #runOutputCodeButton:hover { background: #1e7e34; }


  /* Canvas Positioning */
  #normalCanvas, #hydraCanvas {
    position:absolute; width:300px; height:300px; border:1px solid #000; z-index:10;
    transition: opacity 0.3s;
  }
  #normalCanvas { left:8px; bottom:8px; }
  #hydraCanvas { right:8px; bottom:8px; }

  /* Class for hiding elements */
  .hidden-ui { opacity: 0; pointer-events: none; }
</style>
</head>
<body>

<!-- Virtual Projector Control UI -->
<div id="controlPanel">
    <h3>Projector & Synth Controls</h3>
    
    <!-- Position Sliders -->
    <div class="slider-group">
        <h4>Position</h4>
        <label for="posX">Position X: <span id="valX" class="slider-value">0.00</span></label>
        <input type="range" id="posX" min="-10" max="10" step="0.01" value="0">
        
        <label for="posY">Position Y: <span id="valY" class="slider-value">1.60</span></label>
        <input type="range" id="posY" min="0" max="10" step="0.01" value="1.6">
        
        <label for="posZ">Position Z: <span id="valZ" class="slider-value">3.00</span></label>
        <input type="range" id="posZ" min="-10" max="10" step="0.01" value="3">
    </div>

    <!-- Camera/Projection Parameters -->
    <div class="slider-group">
        <h4>Projection</h4>
        <label for="fov">FOV: <span id="valFov" class="slider-value">80</span>¬∞</label>
        <input type="range" id="fov" min="10" max="120" step="1" value="80">
        
        <label for="near">Near Clip: <span id="valNear" class="slider-value">0.01</span></label>
        <input type="range" id="near" min="0.01" max="1" step="0.01" value="0.01">
        
        <label for="far">Far Clip: <span id="valFar" class="slider-value">10.0</span></label>
        <input type="range" id="far" min="0" max="10" step="0.1" value="10">
    </div>

    <!-- Hydra Setup Code Editor (Runs Once) -->
    <div class="slider-group">
        <h4>Hydra Setup Code (Run Once)</h4>
        <textarea id="hydraSetupCode">// Initialize source 0 with the normal map canvas
s0.init({ src: normalCanvas });

// Initial output chain
src(s0).contrast(6).out();</textarea>
    </div>

    <!-- Hydra Output Code Editor (Main Loop) -->
    <div class="slider-group">
        <h4>Hydra Output Code (Dynamic Loop)</h4>
        <textarea id="hydraOutputCode">// Type your dynamic Hydra code here and press Run.
// This code is executed every frame by the Hydra renderer.

src(s0)
  .modulate(noise(3, 0.1), 0.5)
  .contrast(8)
  .out()</textarea>
        <button id="runOutputCodeButton" onclick="runHydraOutputCode()">‚ñ∂ Run Output Code (Ctrl+Enter)</button>
    </div>
    
    <!-- Save/Load/Toggle Buttons -->
    <div class="button-group">
        <button onclick="saveCameraSettings()">üíæ Save Settings</button>
        <button onclick="loadCameraSettings()">üîÑ Load Saved</button>
        <button class="toggle-button" onclick="toggleUI()">üëÅÔ∏è Hide UI (H)</button>
    </div>
</div>

<a-scene style="background-color: black;"> <!-- Ensure black background for A-Frame -->
  <a-assets>
    <a-asset-item id="park"
      src="https://raw.githubusercontent.com/jrmoren0/HydraConfluencePark/main/hydraConPark/ConfPk.glb">
    </a-asset-item>
  </a-assets>

  <a-entity id="model" gltf-model="#park" position="0 0 -2" scale="0.08 0.08 0.08"></a-entity>

  <a-entity id="cameraRig" position="0 1.6 3" rotation="0 0 0" projector-controls>
    <a-entity camera look-controls wasd-controls></a-entity>
    <a-sky color="#000000"></a-sky> <!-- Black Sky -->
  </a-entity>
</a-scene>

<canvas id="normalCanvas" class="hydra-ui"></canvas>
<canvas id="hydraCanvas" class="hydra-ui"></canvas>

<script>
// --- GLOBAL UI & SYNTH FUNCTIONS ---

const hydraCanvas = document.getElementById('hydraCanvas');
const normalCanvas = document.getElementById('normalCanvas');
const controlPanel = document.getElementById('controlPanel');
const setupEditor = document.getElementById('hydraSetupCode');
const outputEditor = document.getElementById('hydraOutputCode');
let hydra;

function executeHydraCode(code) {
    try {
        // Execute the code string globally using native eval(), as Hydra exposes its functions globally.
        eval(code);
        console.log("Hydra code executed successfully.");
    } catch (e) {
        console.error("Hydra Code Error:", e);
        // Using a custom alert since window.alert() is forbidden in canvas instructions
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: red; color: white; padding: 20px; border-radius: 5px; z-index: 100; font-family: sans-serif;';
        errorMsg.innerHTML = '<strong>Hydra Code Error!</strong> Check console for details.<br><small>Click to dismiss.</small>';
        errorMsg.onclick = () => document.body.removeChild(errorMsg);
        document.body.appendChild(errorMsg);
    }
}

function runHydraOutputCode() {
    executeHydraCode(outputEditor.value);
}

// Keyboard shortcut for running output code (Ctrl+Enter or Cmd+Enter)
outputEditor.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        e.preventDefault();
        runHydraOutputCode();
    }
});

function toggleUI() {
    const isHidden = controlPanel.classList.toggle('hidden-ui');
    
    // Toggle the UI elements
    const uiElements = [controlPanel, normalCanvas, hydraCanvas];
    uiElements.forEach(el => el.classList.toggle('hidden-ui', isHidden));
    
    // Change button text
    const button = controlPanel.querySelector('.toggle-button');
    button.textContent = isHidden ? 'üëÄ Show UI (H)' : 'üëÅÔ∏è Hide UI (H)';
    
    // Optional: Lock mouse when UI is hidden for better scene interaction
    if (!isHidden) {
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
        document.exitPointerLock();
    }
}

// Global listener for the 'h' key
document.addEventListener('keydown', (e) => {
    // Check if the key is 'h' (Key Code 72) and we are not actively typing in an editor
    if (e.key === 'h' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
        toggleUI();
    }
});


function saveCameraSettings() {
    const cameraRigEl = document.querySelector('#cameraRig');
    const cameraEl = cameraRigEl ? cameraRigEl.querySelector('[camera]') : null;
    if (!cameraRigEl || !cameraEl) return;
    
    const pos = cameraRigEl.getAttribute('position');
    const rot = cameraEl.getAttribute('rotation');
    const cam = cameraEl.getAttribute('camera');
    
    const settings = {
        x: pos.x, y: pos.y, z: pos.z,
        rotX: rot.x, rotY: rot.y, rotZ: rot.z,
        fov: cam.fov, near: cam.near, far: cam.far,
        hydraSetupCode: setupEditor.value, // Save setup code
        hydraOutputCode: outputEditor.value // Save output code
    };
    
    localStorage.setItem('projectorSettings', JSON.stringify(settings));
    console.log('Projector settings saved:', settings);
    // Custom alert for save confirmation
    const successMsg = document.createElement('div');
    successMsg.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #28a745; color: white; padding: 20px; border-radius: 5px; z-index: 100; font-family: sans-serif;';
    successMsg.innerHTML = '<strong>Settings Saved!</strong><br><small>Click to dismiss.</small>';
    successMsg.onclick = () => document.body.removeChild(successMsg);
    document.body.appendChild(successMsg);
    setTimeout(() => document.body.removeChild(successMsg), 3000);
}

function loadCameraSettings() {
    const cameraRigEl = document.querySelector('#cameraRig');
    if (!cameraRigEl) {
        console.error('CameraRig element not found.');
        return;
    }
    
    const component = cameraRigEl.components['projector-controls'];
    if (component) {
        component.loadSettingsFromStorage();
        console.log('Projector settings load triggered.');
    } else {
        console.error('Projector controls component not initialized yet.');
    }
}


// --- A-FRAME COMPONENT: Projector (CameraRig) Controls ---

AFRAME.registerComponent('projector-controls', {
    init: function () {
        this.cameraRig = this.el;
        this.cameraEl = this.cameraRig.querySelector('[camera]');
        
        this.sliders = {
            'posX': document.getElementById('posX'),
            'posY': document.getElementById('posY'),
            'posZ': document.getElementById('posZ'),
            'fov': document.getElementById('fov'),
            'near': document.getElementById('near'),
            'far': document.getElementById('far'),
        };
        this.updateAframe = this.updateAframe.bind(this);
        
        Object.values(this.sliders).forEach(slider => {
            slider.addEventListener('input', this.updateAframe);
        });

        // Initial load is attempted here, but Hydra code is executed only after model-loaded
        this.loadSettingsFromStorage(true); // pass true to indicate initial load
    },

    loadSettingsFromStorage: function(isInitialLoad = false) {
        const settings = JSON.parse(localStorage.getItem('projectorSettings'));
        
        if (settings) {
            console.log('Loading saved projector settings.');
            
            // 1. Load Position
            this.setSliderAndEntity('posX', settings.x);
            this.setSliderAndEntity('posY', settings.y);
            this.setSliderAndEntity('posZ', settings.z);
            
            // 2. Load Rotation (applied directly to the camera entity)
            this.cameraEl.setAttribute('rotation', {
                x: settings.rotX,
                y: settings.rotY,
                z: settings.rotZ
            });
            
            // 3. Load Projection
            this.setSliderAndEntity('fov', settings.fov);
            this.setSliderAndEntity('near', settings.near);
            this.setSliderAndEntity('far', settings.far);

            // 4. Load Hydra Code
            if (settings.hydraSetupCode) {
                setupEditor.value = settings.hydraSetupCode;
            }
            if (settings.hydraOutputCode) {
                outputEditor.value = settings.hydraOutputCode;
            }
            
            // Only execute code if Hydra is ready (which happens after model-loaded)
            if (!isInitialLoad && hydra && document.querySelector('#model').components['update-hydra-texture']) {
                executeHydraCode(settings.hydraSetupCode || setupEditor.value);
                runHydraOutputCode();
            }

        } else if (!isInitialLoad) {
            // If not initial load and nothing saved, sync state, but don't overwrite user's typing
            this.syncSlidersFromEntity();
        }
    },
    
    setSliderAndEntity: function(id, value) {
        const slider = this.sliders[id];
        if (slider) {
            slider.value = value;
            this.updateAframe();
        }
    },

    syncSlidersFromEntity: function() {
        const pos = this.cameraRig.getAttribute('position');
        const cam = this.cameraEl.getAttribute('camera');

        this.setSlider('posX', pos.x);
        this.setSlider('posY', pos.y);
        this.setSlider('posZ', pos.z);
        
        this.setSlider('fov', cam.fov);
        this.setSlider('near', cam.near);
        this.setSlider('far', cam.far);
    },

    setSlider: function(id, value) {
        const slider = this.sliders[id];
        if (slider) {
            slider.value = value;
            const valEl = document.getElementById('val' + id.charAt(0).toUpperCase() + id.slice(1));
            let precision = 2;
            if (id === 'fov') precision = 0;
            if (id === 'far') precision = 1;

            if(valEl) valEl.textContent = parseFloat(value).toFixed(precision);
        }
    },

    updateAframe: function() {
        // --- 1. Update Position (Rig) ---
        const newPos = {
            x: parseFloat(this.sliders.posX.value),
            y: parseFloat(this.sliders.posY.value),
            z: parseFloat(this.sliders.posZ.value)
        };
        this.cameraRig.setAttribute('position', newPos);

        // --- 2. Update Camera Parameters (Clipping and FOV) ---
        const newCam = {
            fov: parseFloat(this.sliders.fov.value),
            near: parseFloat(this.sliders.near.value),
            far: parseFloat(this.sliders.far.value)
        };
        this.cameraEl.setAttribute('camera', newCam);

        // --- 3. Update slider value displays ---
        document.getElementById('valX').textContent = newPos.x.toFixed(2);
        document.getElementById('valY').textContent = newPos.y.toFixed(2);
        document.getElementById('valZ').textContent = newPos.z.toFixed(2);

        document.getElementById('valFov').textContent = newCam.fov.toFixed(0);
        document.getElementById('valNear').textContent = newCam.near.toFixed(2);
        document.getElementById('valFar').textContent = newCam.far.toFixed(1);
    }
});


// --- ORIGINAL MODEL & HYDRA LOGIC ---

// Initialize Hydra instance
hydra = new Hydra({ canvas: hydraCanvas, detectAudio: false });


document.querySelector('#model').addEventListener('model-loaded', e => {
    const root = e.detail.model;
    root.updateMatrixWorld(true);

    const ctx = normalCanvas.getContext('2d');
    
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, normalCanvas.width, normalCanvas.height);

    const n = new THREE.Vector3();
    const nWorld = new THREE.Vector3();
    const normalMatrix = new THREE.Matrix3();
    const pointsMeshes = [];
    let yOffset = 0;

    root.traverse(mesh => {
        if (!(mesh.isMesh && mesh.geometry)) return;

        const geom = mesh.geometry.toNonIndexed();
        const normAttr = geom.attributes.normal.array;
        const count = geom.attributes.position.count;

        const texSize = Math.ceil(Math.sqrt(count));
        const meshCanvas = document.createElement('canvas');
        meshCanvas.width = texSize;
        meshCanvas.height = texSize;
        const meshCtx = meshCanvas.getContext('2d');
        const imageData = meshCtx.createImageData(texSize, texSize);

        normalMatrix.getNormalMatrix(mesh.matrixWorld);

        for (let i = 0; i < count; i++) {
            n.set(normAttr[i*3+0], normAttr[i*3+1], normAttr[i*3+2]);
            nWorld.copy(n).applyMatrix3(normalMatrix).normalize();

            const r = Math.floor((nWorld.x * 0.5 + 0.5) * 255);
            const g = Math.floor((nWorld.y * 0.5 + 0.5) * 255);
            const b = Math.floor((nWorld.z * 0.5 + 0.5) * 255);

            const px = i % texSize;
            const py = Math.floor(i / texSize);
            const idx = (py * texSize + px) * 4;
            imageData.data[idx+0] = r;
            imageData.data[idx+1] = g;
            imageData.data[idx+2] = b;
            imageData.data[idx+3] = 255;
        }

        meshCtx.putImageData(imageData, 0, 0);
        ctx.drawImage(meshCanvas, 0, yOffset, normalCanvas.width, normalCanvas.height / 9);
        yOffset += normalCanvas.height / 9;

        pointsMeshes.push({geom, mesh});
        mesh.visible = false;
    });

    // Execute the Setup Code (which handles s0.init)
    executeHydraCode(setupEditor.value);

    const hydraTexture = new THREE.CanvasTexture(hydraCanvas);
    // Setting encoding is crucial for color accuracy
    hydraTexture.encoding = THREE.sRGBEncoding;

    pointsMeshes.forEach(item => {
        const points = new THREE.Points(
            item.geom,
            new THREE.PointsMaterial({
                size: 0.02,
                map: hydraTexture,
                alphaMap: hydraTexture,
                transparent: true,
                alphaTest: 0.1
            })
        );
        points.position.copy(item.mesh.position);
        points.rotation.copy(item.mesh.rotation);
        points.scale.copy(item.mesh.scale);
        item.mesh.parent.add(points);
    });

    AFRAME.registerComponent('update-hydra-texture',{
        tick: function(){ hydraTexture.needsUpdate = true; }
    });
    document.querySelector('#model').setAttribute('update-hydra-texture','');
    
    // Attempt to run the output code once after everything is initialized
    runHydraOutputCode();
});
</script>
</body>
</html>
